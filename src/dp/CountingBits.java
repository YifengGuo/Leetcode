package dp;
/**
 * 
 * @author @Yifeng
 Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the 
 number of 1's in their binary representation and return them as an array.

	Example:
	For num = 5 you should return [0,1,1,2,1,2].
	
	Follow up:
	
	It is very easy to come up with a solution with run time O(n*sizeof(integer)). 
	But can you do it in linear time O(n) /possibly in a single pass?
	Space complexity should be O(n).
	Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
 */

/*
 *  Definition of popcount : 
 *  	The Hamming weight of a string is the number of symbols that are different from the zero-symbol of the alphabet used. 
 *      It is thus equivalent to the Hamming distance from the all-zero string of the same length. For the most typical case, 
 *      a string of bits, this is the number of 1's in the string, or the digit sum of the binary representation of a given number 
 *      and the ℓ₁ norm of a bit vector. In this binary case, it is also called the population count,[1] popcount, sideways sum,[2] or 
 *      bit summation.[3]
 */

/*
 * basic idea:
 * 	DP
 * 	suppose we have an integer x = 605(d) = 1001011101(b)
 * 	and we already calculated and stored all the results of 0 to x - 1
 *  then we know that x is differ by one bit with a number we already calculated
 *  
 *  and they are different only in the most significant bit which is leftmost bit
 *  
 *  for [0,4]
 *  	 0 = 00
 *  	 1 = 01
 *       2 = 10
 *       3 = 11
 *       4 = 100
 *       
 *      we can see that the binary form of 2 and 3 can be generated by adding 1 bit in front of 0 and 1. 
 *      Thus, they are different only by 1 regarding pop count. 
 *      
 *      In general, we have the following transition function for popcount P(i)
 *      P(i + b) = P(i) + 1, where b = 2 ^ m > i
 *      With this transition function, we can then apply Dynamic Programming to generate all the pop counts starting from 0
 */

/*
 * time = O(n)
 * space = O(n)
 */
public class CountingBits {
	public int[] countBits(int num) {
		int[] result = new int[num + 1];
		int i = 0;
		int b = 1; // b must be power of 2 and > i
		while (b <= num) {
			while (i < b && i + b <= num) {
				result[i + b] = result[i] + 1;
				i++;
			}
			i = 0; // rest i
			b <<= 1; // b = 2 * b to make sure
						// b is always power of 2
		}
		return result;
	}
}
